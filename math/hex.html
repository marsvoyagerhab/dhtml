<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Mars Voyager, 2022-08-03 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta charset="UTF-8"/> <!-- HTML5 -->
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/> <!-- HTML4 -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>


        <title>Mars Voyager on Hex</title>


        <meta name="author" content="Mars Voyager"/>
        <meta name="keywords" content="Creativity, DHTML, JavaScript"/>

        <!-- Open Graph: LinkedIn, Facebook -->
        <meta name="title" property="og:title" content="Mars Voyager on Hex"/>
        <meta name="description" property="og:description" content="Explore Maths"/>
        <meta property="og:image:alt" content="Mars Voyager on Hex"/>
        <meta property="og:type" content="Science"/>
        <!-- min 200 x 200 for Facebook -->
        <meta name="image" property="og:image" content="../images/MarsVoyager_100x100.png"/>

        <meta name="apple-mobile-web-app-title" content="Mars Hex"/>
        <meta name="application-name"           content="Mars Hex"/>
        <meta name="msapplication-config"       content="../icons/browserconfig.xml?v=1"/>
        <meta name="msapplication-TileColor"    content="#2b5797"/>
        <meta name="theme-color"                content="#ffffff"/>
        
        <script type="text/javascript" src="../graphics.js"></script>

        <script type="text/javascript" src="../marsvoyager.js"></script>
        
        <link rel="preconnect" href="https://fonts.gstatic.com"/>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Quicksand&amp;display=swap"/> 

        <link rel="stylesheet"        href="../marsvoyager.css" type="text/css"/>
        <link rel="icon"              href="../images/MarsVoyager_100x100.png"/>

        <!-- https://realfavicongenerator.net -->
        <link rel="apple-touch-icon" href="../icons/apple-touch-icon.png?v=1" sizes="180x180"/>
        <link rel="icon"             href="../icons/favicon-32x32.png?v=1"    sizes="32x32" type="image/png"/>
        <link rel="icon"             href="../icons/favicon-16x16.png?v=1"    sizes="16x16" type="image/png"/>
        <link rel="manifest"         href="../icons/site.webmanifest?v=1"/>
        <link rel="mask-icon"        href="../icons/safari-pinned-tab.svg?v=1" color="#5bbad5"/>
        <link rel="shortcut icon"    href="../icons/favicon.ico?v=1"/>
        
        <style>
        h1 {
            padding: 15px 0px;
        }
        img#Pen {
            z-index: 10;
            position: absolute;
            left: 0px;
            top: 0px;
            width: 100px;
            height: 100px;
        }
        div {
            width: 400px;
        }

        input, a.share {
            border: solid 2px #4875B4;
            padding: 3px 6px;
        }
        input {
            margin: 6px 15px;
        }
        a.share {
            margin: 10px 4px;
            text-decoration: none;
        }
        </style>
    </head>
        
    <body>
        <h1>Mars Voyager on Hex</h1>
        
        <div id="FullscreenDiv">
            <canvas id="Canvas" width="600" height="400"></canvas>
        </div>
        
        <div style="padding:15px 0px;">
            <div id="ShareLinks"><div style="padding-bottom:10px;">Share your move:</div></div>
        
            <p>
                <input type="button" id="ShareButton" value="Share"/>
                <input type="button" id="Fullscreen"  value="Fullscreen"/>
                <!-- for debugging -->
                <input type="button" id="random"      value="Random"/>
                <input type="button" id="recalc"      value="Recalc"/>
            </p>
        </div>
        
        <div>
            <ul>
                <li><a href="hex.html">New game</a></li>
        
                <li><label for="Size">Board size:</label>
                    <select id="Size" selectedIndex="3">
                        <option value="3">3x3</option>
                        <option value="6">6x6</option>
                        <option value="9">9x9</option>
                        <option value="11">11x11</option>
                        <option value="13">13x13</option>
                        <option value="14">14x14</option>
                        <option value="19">19x19</option>
                    </select>
                </li>
            </ul>
        
            <hr/>
        
            <div><b>Wikipedia links</b></div>
            <ul>
                <li><a href="https://en.wikipedia.org/wiki/Hex_(board_game)">Hex</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Piet_Hein_(scientist)">Piet Hein</a></li>
            </ul>
        </div> 
         
        <div id="Footer" data-depth="../" data-topic="Hex"></div>

<script>
//<![CDATA[
"use strict"; // don't allow hoisting or undeclared variables
updatePage();
const LOCALEXECUTION = (location.href.indexOf("file:") == 0);
const DEBUG = (true && LOCALEXECUTION);
const SHAREBASELINK = "https://marsvoyagerhab.github.io/dhtml/math/hex.html";

let m_href = window.location.href;
if (DEBUG && (m_href.indexOf("?") > -1)) {
    console.log("Query length: " + m_href.substring(m_href.indexOf("?")).length + " of " + m_href.length);
}

const CANVAS = document.getElementById("Canvas");
const CTX = CANVAS.getContext("2d");
CTX.strokeStyle = "black";
CTX.fillStyle = "white";
CTX.lineWidth = 1;
CTX.font = "18px Arial";
initializeCtxDefault(CANVAS);

const WIDTH = CANVAS.width;
const HEIGHT = CANVAS.height;

const BUTTONS = [];
const BUTTON_R = 14;

const TEXTCOLOR = "#ACA39A"; // same as in CSS
const DARKTEXTCOLOR = "#03081e"; // CSS background

const RED_COLOR = "#ee0000";
const BLUE_COLOR = "#0000ee";
const BOARD_COLOR = "white";
const BOARD_TEXT_COLOR = "#eeeeee";
const BACKGROUND_COLOR = DARKTEXTCOLOR;

const RESERVED = ";/?:@&=+,$"; // what about #
const BIN = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz()-_!.~[]{}<>^|åäöÅÄÖ";
// encoded: []{}<>^| and space and åäöÅÄÖ
for (let i = 0; i < BIN.length; i++) {
    for (let j = 0; j < RESERVED.length; j++) {
        if (BIN.indexOf(RESERVED.charAt(j)) > -1) {
            console.log("Error: BIN defined with reserved letter: " + RESERVED.charAt(j));
        }
    }
}
const BINBASE = 3; // number of states per position, shall be 3
const NBIN = 3; // shall be BINBASE^NBIN <= BIN.length
if (Math.pow(BINBASE, NBIN) > BIN.length) {
    console.log("Error: BIN defined too short (" + BIN.length + ") for NBIN=" + NBIN + ", required length: " + Math.pow(BINBASE, NBIN));
}
if (DEBUG) {
    console.log(encodeURI(BIN));
    console.log(Math.log(BIN.length)/Math.log(BINBASE) + " " + Math.pow(BINBASE, NBIN) + " <=? " + BIN.length);
}
const BINZERO = "0".repeat(NBIN);
function nBinLength(n) {
    return n*n/NBIN + 1;
}

const COLOR_OBJECTS = [
    {
        name:  "Board",
        shortName: "w",
        color: BOARD_COLOR,
        lineWidth: 1,
        shadowBlur: 0,
        empty: true,
    },
    {
        name:  "Red",
        shortName: "r",
        color: RED_COLOR,
        lineWidth: 2,
        shadowBlur: 1,
        empty: false,

        getStartPos: function(c) { return new Vector2D(c, 0); },
        getEndPos:   function(c) { return new Vector2D(c, m_N - 1); },

        isStartEdge: function(pos) { return (pos.y == 0); },
        isOwnEdge:  function(pos) { return ((pos.y == 0) || (pos.y == (m_N - 1))); },
    },
    {
        name:  "Blue",
        shortName: "b",
        color: BLUE_COLOR,
        lineWidth: 2,
        shadowBlur: 1,
        empty: false,
        
        getStartPos: function(r) { return new Vector2D(0,       r); },
        getEndPos:   function(r) { return new Vector2D(m_N - 1, r); },

        isStartEdge: function(pos) { return (pos.x == 0); },
        isOwnEdge: function(pos) { return ((pos.x == 0) || (pos.x == (m_N - 1))); },
    },
];

const RED_OBJECT = COLOR_OBJECTS[1];
const BLUE_OBJECT = COLOR_OBJECTS[2];
RED_OBJECT.next = BLUE_OBJECT;
BLUE_OBJECT.next = RED_OBJECT;
COLOR_OBJECTS[0].next = RED_OBJECT;

const QN = "?N";
const QVERSION = "&V";
const QLAST = "&L";
const QSTATUS = "&S";

const N_DEFAULT = 11;
let m_N = getQueryValue(QN, N_DEFAULT);
const VERSION = getQueryValue(QVERSION, 1);
let m_status;

const mc_translation = {};

let m_lastColor = RED_OBJECT;
let m_lastMove = null;
const last = getQueryValue(QLAST, null);
if (last != null) {
    let c = last.charAt(0);
    switch (c) {
        case RED_OBJECT.shortName:
            m_lastColor = RED_OBJECT;
            break;
        case BLUE_OBJECT.shortName:
            m_lastColor = BLUE_OBJECT;
            break;
        default:
    }
    m_lastMove = getTextPosition(last.substring(1));
    // in case the earlier board was larger
    if ((m_lastMove.x >= m_N) || (m_lastMove.y >= m_N)) {
        m_lastMove = null;
    }
}

const V30 = Math.PI/6;
let m_s; // hex tile side length
let m_dx;
let m_dy;
initLengths();
function initLengths() {
    m_s = Math.min(CANVAS.height, CANVAS.width)/(2*m_N + 1.2);
    m_dx = m_s*Math.cos(V30);
    m_dy = m_s*Math.sin(V30);
}

const SHARE = document.getElementById("ShareButton");
if (navigator.share) {
    // https://css-tricks.com/how-to-use-the-web-share-api/      
    // iOS Safari, desktop Safari
    // Android Chrome, Android Firefox                  
    SHARE.addEventListener("click", event => {
        if (navigator.share) {
            navigator.share({
                title: document.title,
                text: window.location.href,
                url: window.location.href,
            });
        }
    });
} else {
    if (!DEBUG) {
        SHARE.remove();
    } else {
        SHARE.addEventListener("click", event => {
            console.log("Share button clicked, but not enabled.");
        });        
    }
}
/*
}*/

const SIZE = document.getElementById("Size");
const options = SIZE.children;
for (let i = 0; i < options.length; i++) {
    if (options[i].value == m_N) {
        SIZE.selectedIndex = i;
    }
}
SIZE.addEventListener('change', function(event) {
    const newN = SIZE.options.item(SIZE.options.selectedIndex).value;

    if (newN != m_N) {
        // reset the current ctx origin
        translateBack();

        const oldN = m_N;
        const oldStatus = m_status;
        
        const newBinLength = nBinLength(newN);
        let newStatus = "0".repeat(newBinLength);
        
        // loop up to newN
        loopBoard(function(pos) {
            m_N = oldN;
            m_status = oldStatus;
            const colorObj = getStatus(pos);
            if (!colorObj.empty) {
                m_N = newN;
                // swap the status
                m_status = newStatus;
                setStatus(pos, colorObj);
                newStatus = m_status;
            }
        }, newN);
        m_N = newN;
        
        initialize(newStatus);
        draw();
        newQuery();
        drawStatus();
    }
});

initialize();
draw();

const FULLSCREENDIV = document.getElementById("FullscreenDiv");
document.getElementById("Fullscreen").addEventListener('click', function() {
    toggleFullscreen();
});

document.addEventListener('fullscreenchange', function(event) {
    // this event is called after fullscreen request
    if (document.fullscreenElement) {
        fullscreenOpen(); 
    } else {
        fullscreenClosed();
    }
});
window.matchMedia('(orientation: portrait)').addEventListener('change', function(event) {
    // https://dev.to/smpnjn/how-to-detect-device-orientation-with-javascript-29e5
    toggleFullscreen();
});
window.addEventListener('orientationchange', function(event) {
    // https://www.codegrepper.com/code-examples/javascript/detect+screen+rotation+javascript
    // event.target.screen.orientation;
    toggleFullscreen();
});

window.addEventListener('popstate', function(event) {
    const state = event.state;
    
    if (state != null) {
        m_N = state.N;
        m_lastColor = COLOR_OBJECTS[state.lastColor];
        m_lastMove = ((state.lastMove == null) ? null : getTextPosition(state.lastMove));
        m_status = state.state;
    }
    
    // reset the current origin
    translateBack();
    initialize();
    draw();
    
    //let href = window.location.href;
    //href = href.substring(0, href.indexOf("?")); // does not include "?" if available
    //window.location.href = href + state.query;
});

CANVAS.addEventListener('click', function(event) {
    const xy = getEventCoordinates(event);
    const move = getPosition(xy);
   
    if (move != null) {
        if ((m_lastMove != null) && m_lastMove.equals(move)) {
            m_lastMove = null;
        } else if (!getStatus(move).empty) {
            return;
        } else {
            // first set previous move
            if (m_lastMove != null) {
                setStatus(m_lastMove, m_lastColor);
                // color of current move
                m_lastColor = m_lastColor.next;
            }
            m_lastMove = move;
        }
        newQuery();
        drawStatus();
    } else {
        loopButtons(xy, function(button) {
            CTX.strokeStyle = "black";
            CTX.lineWidth = 2;
            drawCircle(button, button.r);
            button.action();
        });
    }
});
CANVAS.addEventListener('mousemove', function(event) {
    // https://stackoverflow.com/questions/17064913/display-tooltip-in-canvas-graph
    const xy = getEventCoordinates(event);
    const move = getPosition(xy);

    CANVAS.title = "";
    if (move == null) {
        loopButtons(xy, function(button) {
            CANVAS.title = button.tooltip;
        });
    }
}, false);

if (DEBUG) {
    document.getElementById("random").addEventListener('click', function() {
        const binLength = nBinLength(m_N);
        m_status = "0".repeat(binLength);

        randomBoard();

        m_lastMove = new Vector2D(1,1);
        m_lastColor = BLUE_OBJECT;

        newQuery();
    
        drawBoard(false);
        const solved = drawStatus();
        
        if (!solved) {
            m_lastMove = new Vector2D(1,1);
            m_lastColor = RED_OBJECT;

            newQuery();
    
            drawBoard(false);
            drawStatus();
        }
    });
    document.getElementById("recalc").addEventListener('click', function() {
        m_lastMove = new Vector2D(1,1);
        m_lastColor = BLUE_OBJECT;

        newQuery();
    
        drawBoard(false);
        const solved = drawStatus();
        
        if (!solved) {
            m_lastMove = new Vector2D(1,1);
            m_lastColor = RED_OBJECT;
    
            drawBoard(false);
            drawStatus();
        }
    });
} else {
    document.getElementById("random").remove();
    document.getElementById("recalc").remove();
}

function initialize(state) {
    if (state == undefined) {
        state = decodeURI(getQueryValue(QSTATUS, ""));
        if (DEBUG) {
            console.log(state);
            console.log(encodeURI(state));
        }
    }
    const binLength = nBinLength(m_N);
    const statusDefault = "0".repeat(binLength);
    m_status = (state + statusDefault).substring(0, binLength);

    initLengths();
}

function getStatus(pos) {
    if (isIllegalPosition(pos)) {
        return COLOR_OBJECTS[0];
    }
    const p = pos.x + m_N*pos.y;
    const n = Math.floor(p/NBIN);
    const bin = NBIN - 1 - (p - n*NBIN);

    return COLOR_OBJECTS[parseInt(getBin(getInt(m_status.charAt(n))).charAt(bin))];
}
function setStatus(pos, colorObj) {
    const p = pos.x + m_N*pos.y;
    
    const n = Math.floor(p/NBIN);
    const i = p - NBIN*n;
    
    const c = m_status.charAt(n);
    
    const colorInt = COLOR_OBJECTS.indexOf(colorObj);
    
    const w = getChar(getInt(c) + colorInt*Math.pow(BINBASE, i));
    m_status = m_status.substring(0, n) + w + m_status.substring(n + 1);
}
function getSolution(colorObj) {
    const time1 = new Date().getTime();
    
    if (colorObj.empty) {
        return false;
    }
    const maxSolutionLoops = Math.max(10, 30 - m_N);
    const maxSolutionAlternatives = 3;
    const maxRemoveClusterLoops = 10;
    const maxRemoveLoops = 12;
    
    const marked = [];
    const starts = [];
    const ends = [];
    
    let rand = [0, 1, 2, 3, 4, 5];
    if (colorObj === RED_OBJECT) {
        rand = [ 0, 1, 2, 3, 4, 5 ];
    } else {
        rand = [ 5, 4, 3, 2, 1, 0 ];
    }
    const randSteps = new Array(6);
    const steps = [ {dx:  0, dy:  1}, // 0
                    {dx:  1, dy:  1}, // 1
                    {dx:  1, dy:  0}, // 2
                    {dx: -1, dy:  0}, // 3
                    {dx: -1, dy: -1}, // 4
                    {dx:  0, dy: -1}, // 5
                  ];

    const setMark = function(arr, pos) {
        if (getStatus(pos) === colorObj) {
            arr.push(pos);
        } else if ((m_lastColor === colorObj) && pos.equals(m_lastMove)) {
            arr.push(pos);
        }
    }
    // the start and goal sides
    for (let i = 0; i < m_N; i++) {
        setMark(starts, colorObj.getStartPos(i));
        setMark(ends,   colorObj.getEndPos(i));
    }
    loopBoard(function(pos) {
        setMark(marked, pos);
    });
    
    const getVectorObjectFromArray = function(arr, x, y) {
        return arr.find(obj => { return ((obj.x == x) && (obj.y == y)); });
    }

    const Neighbours = new Array();
    const getNeighbours = function(pos, marked, level) {
        let pop = true;
        if (Neighbours.length < (level + 1)) {
            Neighbours.push([]);
            pop = false;
        }
        const neighbours = Neighbours[level];
        if (pop) {
            neighbours.splice(0);
        }
        
        randSteps.forEach(step => {
            const p = getVectorObjectFromArray(marked, pos.x + step.dx, pos.y + step.dy);
            if (p != undefined) {
                neighbours.push(p);
            }
        });
        return neighbours;
    }
    // https://www.baeldung.com/cs/check-if-two-nodes-are-connected
    // Depth First Traversal
    const DFS = function(u, v, visited, marked, level) {
        if (u.equals(v)) {
            return true;
        }
        if (u.isInArray(visited)) {
            return false;
        }
        visited.push(u);
        return (getNeighbours(u, marked, level).find(neighbour => { return DFS(neighbour, v, visited, marked, level + 1) }) != undefined);
    }
    
    const initRandSteps = function() {
        rand.forEach((r, i) => {
            randSteps[i] = steps[r];
        });        
    }
    const randomizeArray = function() {
        rand.forEach((r1, i) => {
            const ri = (i > 0 ? Math.floor(Math.random()*(i - 1)) : 0) + (i < 5 ? (1 + Math.floor(Math.random()*(5 - i))) : 0);
            const r2 = rand[ri];
            rand[i] = r2;
            rand[ri] = r1;
        });
        
        // ?N=19&V=1&L=rB2&S=HQPEHGDMGHEDMDEMEHPHMGDQGHEMPDHPHQNNDPHEDMEHEEDMQDPMEHHHNHQEEPDHHMNPMPGQMHHGQMPNGMNDQQEQGMNGQNNNPDQPMNEPNEMMPGQNGEQQQMGE2
        //rand = [2,5,0,4,3,1];
        
        // N=19&V=1&L=rB2&S=DGNEENQEENDNGDGGNMHNQPQHGHHGDQGPQMNHQGDPPMDNEGPEGMNQDHPDHNGPNPHMMEGHNGNEDGNPGPEHDMQQEQMNQNNQGQMNEDGEHNMQHEHPQEMGEGQHQGEP1
        //rand = [1,3,0,5,2,4];
        
        // N=13&V=1&L=bB2&S=DMDMMEQQMPMHMEQPHPDMNMHNHPNHGPEENQPHGEGGHQDPQMDEMQNPMMGD1
         //rand = [1,0,4,5,3,2];
        
        initRandSteps();
    }
    
    const checkSolution = function(solution, startPos, endPos) {
        let solutionFound = false;
        for (let i = 0; (i < maxSolutionLoops) && (!solutionFound); i++) {
            if (i != 0) { // no random in first loop
                randomizeArray();
            }
            if (DFS(startPos, endPos, [], solution, 0)) {
                solutionFound = true;
            }
        }
        return solutionFound;
    }

    const time2 = new Date().getTime();
    
    let shortest = m_N*m_N;
    let shortestPath = [];
    let bestRand = rand.slice();
    initRandSteps();
    
    let usedStart = null;
    let usedEnd = null;
    
    let solutionLoops = 0;
    let solutionAlternatives = 0;
    
    // Find solution
    for (let i = 0; (i < maxSolutionLoops) && (solutionAlternatives < maxSolutionAlternatives); i++) {
        solutionLoops++;
        randomizeArray();
        
        starts.forEach(startPos => {
            ends.forEach(endPos => {
                const visited = [];
                if (DFS(startPos, endPos, visited, marked, 0)) {
                    // found solution
                    visited.push(endPos);
                    
                    if (visited.length < shortest) {
                        // avoid forks at start or end
                        let atHome = 0;
                        shortestPath.forEach(pos => {
                            if (colorObj.isOwnEdge(pos)) {
                                atHome++;
                            }
                        });
                        if (atHome == 2) {
                            solutionAlternatives++;
                        }
                        // must save this, even though atHome != 2
                        usedStart = startPos;
                        usedEnd = endPos;
                
                        shortest = visited.length;
                        shortestPath = visited;
                        bestRand = rand.slice();
                    }
                }
            });
        });
    }

    const time3 = new Date().getTime();
    
    // Solution has been found
    if (shortestPath.length > 0) {
        const drawRemoved = function(positions, r, color) {
            if (DEBUG) {
                const lineWidth = CTX.lineWidth;
                CTX.strokeStyle = color;
                CTX.lineWidth = 2.5;
                positions.forEach(pos => {
                    drawCircle(getPositionXY(pos), r*m_s/3);
                });
                CTX.lineWidth = lineWidth;
            }            
        }
        const isNeighbours = function(pos1, pos2) {
            let ok = false;
            steps.forEach(step => {
                ok = (ok || pos1.equals(pos2.x + step.dx, pos2.y + step.dy));
            });
            return ok;
        }
        const checkHome = function(home, pos) {
            if (home != null) {
                if (usedStart.equals(pos)) {
                    usedStart = home;
                } else if (usedEnd.equals(pos)) {
                    usedEnd = home;
                }
            }            
        }
        
        const removeClusters = function() {
            let anyRemoved = true;
            for (let k = 0; (k < maxRemoveClusterLoops) && anyRemoved; k++) {
                removeClusterLoops++;
                anyRemoved = false;
                for (let i = shortestPath.length - 1; i > -1; i--) {
                    const pos = shortestPath[i];
                    const neighbours = getNeighbours(pos, shortestPath, 0);
                    const len = neighbours.length;
                    let home = null;
                
                    let remove = (len == 0);
                    if (len == 1) {
                        if (!colorObj.isOwnEdge(pos)) {
                            remove = true;
                        } else if (colorObj.isOwnEdge(pos) && colorObj.isOwnEdge(neighbours[0])) {
                            remove = true;
                            home = neighbours[0];
                        }
                    } else {
                        if ((len == 2) && isNeighbours(neighbours[0], neighbours[1])) {
                            if (colorObj.isOwnEdge(pos)) {
                                const h0 = colorObj.isOwnEdge(neighbours[0]);
                                const h1 = colorObj.isOwnEdge(neighbours[1]);
                                remove = (h0 || h1);
                                home = (h0 ? neighbours[0] : neighbours[1]);
                            } else {
                                remove = true;
                            }
                        } else if ((len == 3) && (!colorObj.isOwnEdge(pos))) {
                            const c01 = isNeighbours(neighbours[0], neighbours[1]);
                            const c02 = isNeighbours(neighbours[0], neighbours[2]);
                            const c12 = isNeighbours(neighbours[1], neighbours[2]);
                            remove = ((c01 && c02) || (c01 && c12) || (c02 && c12));
                        }
                    }
                    if (remove) {
                        shortestPath.splice(i, 1);
                        checkHome(home, pos);
                        anyRemoved = true;
                        drawRemoved([pos], 0.9, "pink");
                    }
                }
            }
        }
        
        let removeClusterLoops = 0;
        removeClusters();
        
        let removeLoops = 0;
        let anyRemoved = true;
        for (let k = 0; (k < maxRemoveLoops) && anyRemoved; k++) {
            removeLoops++;
            anyRemoved = false;
            
            // remove loops
            let foundLoop = false;
            shortestPath.forEach((pos, index) => {
                if (!foundLoop) {
                    for (let i = index + 2; (i < shortestPath.length) && (!foundLoop); i = i + 1) {
                        if (isNeighbours(pos, shortestPath[i])) {
                            for (let j = index + 2; (j < (i - 1)) && (!foundLoop); j = j + 1) {                            
                                let copy = shortestPath.slice();
                                let removed = shortestPath.splice(j, 1);
                            
                                removeClusters();
                            
                                if (!checkSolution(shortestPath, usedStart, usedEnd)) {
                                    shortestPath = copy;
                                } else {
                                    drawRemoved(removed, 2, "black");
                                    foundLoop = true;
                                    anyRemoved = true;
                                }
                            }
                        }
                    }
                }
            });
            
            // check again for forks
            /*
            let atHome = 0;
            const homes = [];
            shortestPath.forEach(pos => {
                if (colorObj.isOwnEdge(pos)) {
                    atHome++;
                    homes.push(pos);
                }
            });
            if (atHome != 2) {
                for (let i = 0; i < homes.length; i++) {
                    const pos = homes[i];
                    const home = (i > 0 ? homes[i - 1] : homes[i + 1]);
                    checkHome(home, pos);
                    
                    let copy = shortestPath.slice();
                    let removed = shortestPath.splice(i, 1);
                
                    removeClusters();
                    
                    // should be safe to remove, but perform check
                    if (!checkSolution(shortestPath, usedStart, usedEnd)) {
                        shortestPath = copy;
                        checkHome(pos, home); // restoring
                    } else {
                        drawRemoved(removed, 1.7, "green");
                        anyRemoved = true;
                    }
                }
            }
            */
        }
        
        if (DEBUG) {
            //console.log(shortestPath);
            logVariable({bestRand});
            logVariable({solutionLoops, solutionAlternatives, removeClusterLoops, removeLoops});
            const t = new Date().getTime();
            console.log("time " + (t - time1) + " = " + (time3 - time2) + " + " + (t - time3));
        }
        return shortestPath;
    }
    return false;
}

// https://stackoverflow.com/questions/49223096/is-there-a-way-to-document-parameters-of-a-function-parameter
/**
 * A function to be passed as an argument.
 * @callback loopBoardCallback
 * @param {Vector2D} pos - The position.
 */
/**
 * Loops through all positions of the board and calls the callback function.
 * @param {loopBoardCallback} fcn - Callback for each cell in the board.
 * @param {integer} [n = m_N]     - Loop length, same for column and row.
 */
function loopBoard(fcn, n) {
    if (n == undefined) {
        n = m_N;
    }
    for (let r = 0; r < n; r++) { // y
        for (let c = 0; c < n; c++) { // x
            fcn(new Vector2D(c, r));
        }
    }
}


/* SUPPORTING FUNCTIONS */

function getChar(i) {
    return BIN.charAt(i);
}
function getInt(c) {
    return BIN.indexOf(c);
}
function getBin(i) { // Most significant bit first
    let s = "";
    let n = NBIN;
    while (n > -1) {
        let q = (BINBASE - 1)*Math.pow(BINBASE, n);
        if (i >= q) {
            s = s + "2";
            i = i - q;
        } else {
            q = q/2;
            if (i >= q) {
                s = s + "1";
                i = i - q;
            } else {
                s = s + "0";
            }
        }
        n--;
    }
    s = BINZERO + s;
    s = s.substring(s.length - NBIN);
    return s;
}

function getPositionText(pos) {
    if (pos == null) {
        return null;
    }
    return String.fromCharCode(65 + pos.x) + (pos.y + 1);
}
function getTextPosition(txt) {
    return new Vector2D(txt.charCodeAt(0) - 65, parseInt(txt.substring(1)) - 1);
}
function isIllegalPosition(pos) {
    return ((pos == null) || 
            (pos.x < 0) || (pos.x >= m_N) ||
            (pos.y < 0) || (pos.y >= m_N));
}
function getPositionXY(pos) {
    const x = pos.x*2*m_dx - pos.y*m_dx;
    const y = pos.y*(m_dy + m_s);
    return new Vector2D(x, y);
}
function getPosition(xy) {
    const pos = new Vector2D();
    pos.x = Math.floor((xy.x + m_dx)/(2*m_dx));
    pos.y = Math.floor((xy.y + m_s)/(3*m_s/2));
    if (pos.y % 2 > 0.5) {
        pos.x = Math.floor((xy.x + m_dx)/(2*m_dx) + 0.5);
    }
    pos.x = Math.floor(pos.x + pos.y/2);
    
    const centerXY = getPositionXY(pos);
    if (xy.minus(centerXY).length() > m_s*0.9*Math.cos(V30)) {
        return null;
    }
    if (!isIllegalPosition(pos)) {
        return pos;
    }
    return null;
}

function randomBoard() {
    loopBoard(function(pos) {setStatus(pos, COLOR_OBJECTS[Math.floor(Math.random()*2 + 1)])});
}


/* GRAPHICS */

function draw() {
    CTX.fillStyle = BACKGROUND_COLOR;
    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
    
    const n = (m_N - 1)/2;
    mc_translation.x = CANVAS.width/2 - m_dx*n;
    mc_translation.y = CANVAS.height/2 - m_s*n - m_dy*n;
    translate(mc_translation);
    
    drawBoard(false);
    drawStatus();
}

function drawStatus(ctx) {
    updateShareLinks();
    if (ctx == undefined) {
        ctx = CTX;
    }
    function drawColoredHex(pos, colorObj) {
        if (colorObj == undefined) {
            colorObj = getStatus(pos);
        }
        if (isIllegalPosition(pos)) {
            return;
        }
        ctx.fillStyle = colorObj.color;
        ctx.lineWidth = colorObj.lineWidth*m_s/20;
        
        setShadow("#444444", colorObj.shadowBlur*ctx.lineWidth/4);
        
        drawHexPosition(pos, ctx);
        
        clearShadow();
    }
    
    ctx.strokeStyle = "black";
    loopBoard(function(pos) {
        drawColoredHex(pos);
    });
    
    let solved = false;
    if (m_lastMove != null) {
        drawColoredHex(m_lastMove, m_lastColor);
        solved = drawSolution(m_lastColor, ctx);
    }
    
    // mark next move side
    
    const r = Math.PI/2;
    const W = CANVAS.width;
    const H = CANVAS.height;

    function drawSide(a, w, h, color) {
        ctx.strokeStyle = color;
        rotate(a);
        drawLine(0, 0, w, 0, ctx);
        drawLine(0, h, w, h, ctx);
        rotateBack();
    }

    ctx.lineWidth = 10;
    const translation = translateBack();

    let color = BACKGROUND_COLOR;
    drawSide(0, W, H,  color);
    drawSide(r, H, -W, color);

    if (m_lastMove == null) {
        if (m_lastColor === RED_OBJECT) {
            drawSide(0, W, H, RED_COLOR);
        } else {
            m_lastColor = BLUE_OBJECT;
            drawSide(r, H, -W, BLUE_COLOR);
        }
    } else {
        if (m_lastColor === RED_OBJECT) {
            drawSide(r, H, -W, BLUE_COLOR);
        } else {
            drawSide(0, W, H, RED_COLOR);
        }
    }
    translate(translation);
    resetStyle(ctx);
    return solved;
}

function drawBoard(drawTiles, ctx) {
    if (ctx == undefined) {
        ctx = CTX;
    }

    function drawBorder() {
        ctx.beginPath();
    
        const by = m_s*1.2; // border from mid of top left side

        ctx.moveTo(0, 0);
        const y = -(m_s - m_dy/2) - by;
        ctx.lineTo(Math.tan(V30)*y, y);
    
        translate((m_N - 1)*2*m_dx, 0);
        ctx.lineTo(-Math.tan(2*V30)*y, y);
        ctx.lineTo(0, 0);
        translateBack();
    
        ctx.closePath();    
        ctx.fill();
    }
    
    ctx.fillStyle = RED_COLOR;
    
    // top
    drawBorder();
    
    const opposite = getPositionXY(new Vector2D(-(m_N - 1), -(m_N - 1)));
    
    // bottom
    scale(-1, -1);
    translate(opposite);            
    drawBorder();            
    translateBack(); 
    scaleBack();

    ctx.fillStyle = BLUE_COLOR;
    
    // left
    rotate(-2*V30);
    scale(-1, 1);
    drawBorder();
    
    // right
    scale(-1, -1);
    translate(opposite);           
    drawBorder();            
    translateBack(); 
    scaleBack();
    
    scaleBack();
    rotateBack();

    if (drawTiles) {
        ctx.strokeStyle = "black";
        ctx.fillStyle = BOARD_COLOR;
        loopBoard(function(pos) {
            drawHexPosition(pos);
        });
    }

    ctx.fillStyle = BOARD_TEXT_COLOR;
    ctx.font = Math.floor(m_s) + "px Arial";
        
    const n = m_N - 1;
    for (let i = 0; i < m_N; i++) {
        const row = i + 1;
        const col = String.fromCharCode(65 + i);
        
        let q = 1.4;
        let qx = q*m_dx;
        const qy = q*m_dy;
        translate(i*2*m_dx, 0); // center of hexagon in first row
        drawTextCentered( qy, -qx, col); // note swapping qx and qy
        translate(-n*m_dx, n*(m_s + m_dy)); // center of hexagon in last row
        drawTextCentered(-qy,  qx, col); // note swapping qx and qy
        translateBack();
        translateBack();
        
        q = 1.7;
        qx = q*m_dx;
        translate(-i*m_dx, i*(m_s + m_dy)); // center of hexagon in first column
        drawTextCentered(-qx, 0, row);
        translate(n*2*m_dx, 0); // center of hexagon in last column
        drawTextCentered( qx, 0, row);
        translateBack();
        translateBack();
    }
    
    // remove all old buttons, TODO remove from ctx
    BUTTONS.splice(0);

    const buttonPosition = 2.2*BUTTON_R;
    
    drawButton(buttonPosition, buttonPosition, "<", "Back", function() {
        window.history.back();
    }, ctx);
    
    drawButton(2*buttonPosition, buttonPosition, ">", "Forward", function() {
        window.history.forward();
    }, ctx);
    
    drawButton(3*buttonPosition, buttonPosition, "F", "Fullscreen toggle", function() {
        toggleFullscreen();
    }, ctx);
    
    drawButton(4*buttonPosition, buttonPosition, "S", "Share", function() {
        // https://stackoverflow.com/questions/809057/how-do-i-programmatically-click-on-an-element-in-javascript
        SHARE.dispatchEvent(new MouseEvent("click", {
            "view": window,
            "bubbles": true,
            "cancelable": false
        }));
    }, ctx);
}
function drawSolution(colorObj, ctx) {
    if (ctx == undefined) {
        ctx = CTX;
    }
    const solution = getSolution(colorObj);
    if (solution) {
        if (DEBUG) {
            console.log("Solved by " + colorObj.name + ", path length: " + solution.length);
        }

        ctx.strokeStyle = "black";
        ctx.fillStyle = "yellow";
        solution.forEach(pos => {
            const a = getPositionXY(pos);
            const r = m_s/2;
            fillCircle(a, r, ctx);
            drawCircle(a, r, ctx);
        });
        return true;
    }
    return false;
}

function drawHexPosition(pos, ctx) {
    if (ctx == undefined) {
        ctx = CTX;
    }
    drawHex(getPositionXY(pos), ctx);
}
function drawHex(a, ctx) { // center at a
    if (ctx == undefined) {
        ctx = CTX;
    }
    ctx.beginPath();
    
    translate(a.x, a.y - m_s, ctx);
    ctx.moveTo(0, 0); // starting at top
    ctx.lineTo(m_dx, m_dy);
    ctx.lineTo(m_dx, m_dy + m_s);
    ctx.lineTo(0, 2*m_dy + m_s);
    ctx.lineTo(-m_dx, m_dy + m_s);
    ctx.lineTo(-m_dx, m_dy);
    translateBack();
    
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
}

// note x, y in default canvas coordinates
function drawButton(x, y, txt, tooltip, actionFcn, ctx) {
    if (ctx == undefined) {
        ctx = CTX;
    }
    const translation = translateBack();
    ctx.fillStyle = "gold";
    fillCircle(x, y, BUTTON_R, ctx);
    
    ctx.font = "bold " + BUTTON_R + "px Arial";
    drawTextCentered(x, y, txt, "black", CTX_TRANSPARENT_COLOR, ctx);
    translate(translation);
    
    const button = new Vector2D(x - translation.x, y - translation.y);
    
    button.r = BUTTON_R;
    button.tooltip = tooltip;
    button.action = actionFcn;
    
    BUTTONS.push(button);
}
function loopButtons(xy, fcn) {
    BUTTONS.forEach(button => {
        if (xy.minus(button).length() < button.r) {
            fcn(button);
        }
    });
}
function getEventCoordinates(event) {
    let rect = event.target.getBoundingClientRect();
    const x = event.clientX - rect.left - mc_translation.x;
    const y = event.clientY - rect.top - mc_translation.y;
    return new Vector2D(x, y);
}


// https://www.w3schools.com/jsref/met_element_exitfullscreen.asp
function toggleFullscreen() {
    if (document.fullscreenElement) {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { // Safari
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { // IE11
            document.msExitFullscreen();
        }
    } else {
        const elem = FULLSCREENDIV;
    
        if (elem.requestFullscreen) {
            // https://stackoverflow.com/questions/23913111/firefox-browser-rejected-fullscreen-change
            // Mozilla Firefox insists that the code in the event handler executes under 1 second. 
            // Request for fullscreen was denied because Element.requestFullscreen() was not called from inside a short running user-generated event handler.
            // seems to happen when trying to open in event handler 'fullscreenchange'
            elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) { // Safari
            elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) { // IE11
            elem.msRequestFullscreen();
        }
    }
}
function fullscreenOpen() {
    setTimeout(function () {
        // reset the current origin
        translateBack();
    
        CANVAS.width = window.screen.availWidth;
        CANVAS.height = window.screen.availHeight;

        initLengths();
        draw();
    }, 700);
}
function fullscreenClosed() {
    // reset the current origin
    translateBack();

    CANVAS.width = WIDTH;
    CANVAS.height = HEIGHT;

    initLengths();
    draw();
}


/* QUERY */

//{
// separate blue and red
// bin 2: ?N=19&L=bS18&R=00000000000000000000000000000000000000000000000000000000000G1&B=00000000000000000000000000000000000000000000000000000000000W

// binbase 2: ?N=19&V=1&L=bB2&
//    S=4000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000062
// binbase 3: ?N=19&L=bS17&
//    S=fViA000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090000002
// becomes encoded:
// binbase 4: ?N=19&V=1&L=bP18&
//    S=G000söQ00aeG00dee00ÅÅQ0R83000420000200000000a4000ä2000000000000000000000000000000000s8000d1
//      40000000082000000000000000000s000003600903100000000000010006060000000000012006030Reee7%C3%A4%C3%85%C3%85%C3%851
//      i%5Doh%7C%7Br%7Bfnr%5Dh~~q.~%C3%A5%5D%C3%A5%5Do%C3%B6roqinq~%7B%5Di~eo%C3%85%C3%85r%7B%7Bei%C3%B6%C3%85ffef%7Bqrri%C3%A5%7Boqeq%C3%85erfofehh%5D~fe%C3%A5ih%C3%B6h.err.f%C3%A5%C3%85i%C3%B6%7C2
/*
}*/
function newQuery() {
    const state = {
        N: m_N,
        lastColor: COLOR_OBJECTS.indexOf(m_lastColor),
        lastMove: ((m_lastMove == null) ? null : getPositionText(m_lastMove)),
        state: m_status,
    };
    let query = QN + "=" + m_N;
    query = query + QVERSION + "=" + 1;
    
    let titleInfo = new Date().toLocaleString('sv', { timeZoneName: 'short' }).substring(0, 16).replaceAll(" ", "T");
    if (m_lastMove != null) {
        query = query + QLAST + "=" + m_lastColor.shortName + getPositionText(m_lastMove);
        titleInfo = m_lastColor.name + " " + getPositionText(m_lastMove) + " " + titleInfo;
    }
    
    const theState = function(state) {
        let query = "";
        let last = false;
        for (let i = Math.min(state.length - 1, m_N*m_N/NBIN); i > -1 ; i--) { // use N, as it may have been changed
            if (state.charAt(i) != "0") {
                last = true;
            }
            if (last) {
                query = state.charAt(i) + query;
            }
        }
        if (!last) {
            query = "0";
        }
        return query;
    }
    query = query + QSTATUS + "=" + encodeURI(theState(m_status));
        
    let href = window.location.href;
    href = href.substring(0, href.indexOf("?")); // does not include "?" if available
    
    m_href = href + query;
    
    const title = document.getElementsByTagName("TITLE")[0];
    const earlierTitle = title.innerText;
    title.innerText = title.innerText + " " + titleInfo; 
    
    setTimeout(function() {
        history.pushState(state, "", m_href);
        title.innerText = earlierTitle;
    }, 10);
}
function updateShareLinks() {
    // https://schier.co/blog/pure-html-share-buttons
    // https://developers.facebook.com/tools/debug/
    // https://www.linkedin.com/post-inspector/

    let title = encodeURI(document.title);
    let url = encodeURIComponent(window.location.href);
    
    if (LOCALEXECUTION) {
        url = encodeURIComponent(SHAREBASELINK) + window.location.search;
    }

    let links = [];
    links.push({id:"Mail",     url:"mailto:?subject=" + title + "&body=" + url});
    links.push({id:"Twitter",  url:"https://twitter.com/share?url=" + url + "&text=" + title}); // &text=<TEXT>via=<USERNAME>
    links.push({id:"LinkedIn", url:"https://www.linkedin.com/shareArticle?url=" + url + "&title=" + title + "&summary=" + title});
    links.push({id:"Facebook", url:"https://www.facebook.com/sharer/sharer.php?u=" + url});

    let share = document.getElementById("ShareLinks");
    
    links.forEach(link => {
        let a = document.getElementById(link.id);
        if (a == null) {
            a = document.createElement("A");
            a.className = "share";
            a.setAttribute("class", "share");
            a.id = link.id;
            a.innerHTML = a.id;
            share.appendChild(a);
        }
        a.href = link.url;
    });
}


/* OTHERS */

function logVariable(obj) { // use as logVariables({theVariableNameToBeLogged})
    // can just as well just log the object directly... but this is cooler
    // https://stackoverflow.com/questions/4602141/variable-name-as-a-string-in-javascript
    let s = "";
    Object.keys(obj).forEach((key, i) => {
        s = s + key + ": " + Object.values(obj)[i];
        if (i < (Object.keys(obj).length - 1)) {
            s = s + ", ";
        }
    });
    console.log(s);
}


//]]>
</script>
    </body>
</html>
