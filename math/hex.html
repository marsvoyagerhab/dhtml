<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Mars Voyager, 2022-08-03 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta charset="UTF-8"/> <!-- HTML5 -->
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/> <!-- HTML4 -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>


        <title>Mars Voyager on Hex</title>


        <meta name="author" content="Mars Voyager"/>
        <meta name="keywords" content="Creativity, DHTML, JavaScript"/>

        <!-- Open Graph: LinkedIn, Facebook -->
        <meta name="title" property="og:title" content="Mars Voyager on Hex"/>
        <meta name="description" property="og:description" content="Explore Maths"/>
        <meta property="og:image:alt" content="Mars Voyager on Hex"/>
        <meta property="og:type" content="Science"/>

        <!-- min 200 x 200 for Facebook -->
        <meta name="image" property="og:image" content="../images/MarsVoyager_100x100.png"/>

        <meta name="apple-mobile-web-app-title" content="Mars Hex"/>
        <meta name="application-name"           content="Mars Hex"/>
        <meta name="msapplication-config"       content="../icons/browserconfig.xml?v=1"/>
        <meta name="msapplication-TileColor"    content="#2b5797"/>
        <meta name="theme-color"                content="#ffffff"/>
        
        <script type="text/javascript" src="../graphics.js"></script>

        <script type="text/javascript" src="../marsvoyager.js"></script>
        
        <link rel="preconnect" href="https://fonts.gstatic.com"/>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Quicksand&amp;display=swap"/> 

        <link rel="stylesheet"        href="../marsvoyager.css" type="text/css"/>
        <link rel="icon"              href="../images/MarsVoyager_100x100.png"/>

        <!-- https://realfavicongenerator.net -->
        <link rel="apple-touch-icon" href="../icons/apple-touch-icon.png?v=1" sizes="180x180"/>
        <link rel="icon"             href="../icons/favicon-32x32.png?v=1"    sizes="32x32" type="image/png"/>
        <link rel="icon"             href="../icons/favicon-16x16.png?v=1"    sizes="16x16" type="image/png"/>
        <link rel="manifest"         href="../icons/site.webmanifest?v=1"/>
        <link rel="mask-icon"        href="../icons/safari-pinned-tab.svg?v=1" color="#5bbad5"/>
        <link rel="shortcut icon"    href="../icons/favicon.ico?v=1"/>
        
        <style>
        h1 {
            padding: 15px 0px;
        }
        div {
            width: 400px;
        }

        input, a.share {
            border: solid 2px #4875B4;
            padding: 3px 6px;
        }
        input {
            margin: 6px 15px;
        }
        a.share {
            margin: 10px 4px;
            text-decoration: none;
        }
        </style>
    </head>
        
    <body>
        <h1>Mars Voyager on Hex</h1>
        
        <div id="FullscreenDiv">
            <canvas id="Canvas" width="600" height="400"></canvas>
        </div>
        
        <div style="padding:15px 0px;">
            <div id="ShareLinks"><div style="padding-bottom:10px;">Share your move: <input type="button" id="ShareButton" value="Share"/></div></div>
        
            <p>
                <input type="button"   id="Fullscreen"  value="Full screen"/>
                <div id="Debug">
                    <input type="button"   id="random"  value="Random"/>
                    <input type="button"   id="recalc"  value="Recalc"/>
                    <input type="checkbox" id="edit"/>
                </div>
            </p>
        </div>
        
        <div>
            <ul>
                <li><a id="New" href="hex.html">New game</a></li>
        
                <li><label for="Size">Board size:</label>
                    <select id="Size" selectedIndex="3">
                        <option value="3">3x3</option>
                        <option value="6">6x6</option>
                        <option value="9">9x9</option>
                        <option value="11">11x11</option>
                        <option value="13">13x13</option>
                        <option value="14">14x14</option>
                        <option value="19">19x19</option>
                    </select>
                </li>
            </ul>
        
            <hr/>
        
            <div><b>Wikipedia links</b></div>
            <ul>
                <li><a href="https://en.wikipedia.org/wiki/Hex_(board_game)">Hex</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Piet_Hein_(scientist)">Piet Hein</a></li>
            </ul>
        </div> 
         
        <div id="Footer" data-depth="../" data-topic="Hex"></div>

<script>
//<![CDATA[
"use strict"; // don't allow hoisting or undeclared variables
// to be modified at deployment:
const LOCALEXECUTION = (location.href.indexOf("file:") == 0);
const SETTINGS = {
     fileLastModified: "2022-08-31T21:45",
     debug: (false && LOCALEXECUTION),
};
updatePage(SETTINGS);
const DEBUG = SETTINGS.debug;
const FILE_NAME = "hex.html";
const SHAREBASELINK = "https://marsvoyagerhab.github.io/dhtml/math/hex.html";

let m_href = window.location.href;
let m_previousHref = m_href;
let m_firstDraw = true;
if (DEBUG && (m_href.indexOf("?") > -1)) {
    //console.log("Query length: " + m_href.substring(m_href.indexOf("?")).length + " of " + m_href.length);
}

const CANVAS = document.getElementById("Canvas");
const WIDTH = CANVAS.width;
const HEIGHT = CANVAS.height;
let m_screenWidth = 0;
let m_screenHeight = 0;
let m_screenQuota = 0;
let m_fullscreen = false;

const CTX = CANVAS.getContext("2d");
CTX.strokeStyle = "black";
CTX.fillStyle = "white";
CTX.lineWidth = 1;
CTX.font = "18px Arial";
initializeCtxDefault(CANVAS);

const BUTTONS = [];

const TEXTCOLOR = "#ACA39A"; // same as in CSS
const DARKTEXTCOLOR = "#03081e"; // CSS background

const RED_COLOR = "#cc0000";
const BLUE_COLOR = "#0000cc";
const BOARD_COLOR = "#eeeeee";
const BOARD_TEXT_COLOR = BOARD_COLOR;
const BACKGROUND_COLOR = DARKTEXTCOLOR;

const RESERVED = ";/?:@&=+,$"; // what about #
const BIN = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz()-_!.~[]{}<>^|åäöÅÄÖ";
// encoded: []{}<>^| and space and åäöÅÄÖ
for (let i = 0; i < BIN.length; i++) {
    for (let j = 0; j < RESERVED.length; j++) {
        if (BIN.indexOf(RESERVED.charAt(j)) > -1) {
            console.log("Error: BIN defined with reserved letter: " + RESERVED.charAt(j));
        }
    }
}
const BINBASE = 3; // number of states per position, shall be 3
const NBIN = 3; // shall be BINBASE^NBIN <= BIN.length
if (Math.pow(BINBASE, NBIN) > BIN.length) {
    console.log("Error: BIN defined too short (" + BIN.length + ") for NBIN=" + NBIN + ", required length: " + Math.pow(BINBASE, NBIN));
}
if (DEBUG) {
    //console.log(encodeURI(BIN));
    //console.log(Math.log(BIN.length)/Math.log(BINBASE) + " " + Math.pow(BINBASE, NBIN) + " <=? " + BIN.length);
}
const BINZERO = "0".repeat(NBIN);
function nBinLength(n) {
    return n*n/NBIN + 1;
}

const COLOR_OBJECTS = [
    {
        name:  "Board",
        shortName: "w",
        color: BOARD_COLOR,
        lineWidth: 1,
        shadowBlur: 0,
        empty: true,
    },
    {
        name:  "Red",
        shortName: "r",
        color: RED_COLOR,
        lineWidth: 1.5,
        shadowBlur: 1,
        empty: false,
        markColor: "gold",

        isStartEdge: function(pos) { return (pos.y == 0); },
        isEndEdge:   function(pos) { return (pos.y == (m_N - 1)); },
        isOwnEdge:   function(pos) { return (this.isStartEdge(pos) || this.isEndEdge(pos)); },
    },
    {
        name:  "Blue",
        shortName: "b",
        color: BLUE_COLOR,
        lineWidth: 1.5,
        shadowBlur: 1,
        empty: false,
        markColor: "#efc700", // darker than "gold" = "#ffd700"

        isStartEdge: function(pos) { return (pos.x == 0); },
        isEndEdge:   function(pos) { return (pos.x == (m_N - 1)); },
        isOwnEdge:   function(pos) { return (this.isStartEdge(pos) || this.isEndEdge(pos)); },
    },
];

const RED_OBJECT = COLOR_OBJECTS[1];
const BLUE_OBJECT = COLOR_OBJECTS[2];
{
    RED_OBJECT.next = BLUE_OBJECT;
    BLUE_OBJECT.next = RED_OBJECT;
    COLOR_OBJECTS[0].next = RED_OBJECT;
}

// steps to neighbours of a hexagon, prio direction for red from start to end
const steps = [ { dx:  0, dy:  1 }, // 0 left  bottom
                { dx:  1, dy:  1 }, // 1 right bottom
                { dx: -1, dy:  0 }, // 2 left
                { dx:  1, dy:  0 }, // 3 right
                { dx: -1, dy: -1 }, // 4 left  top
                { dx:  0, dy: -1 }, // 5 right top
              ];

const HEX_LINE_QUOTE = 20; // usage lineWidth*m_s/HEX_LINE_QUOTE

const QN = "?N";
const QVERSION = "&V";
const QLAST = "&L";
const QSTATUS = "&S";

const N_DEFAULT = 11;
let m_N = parseInt(getQueryValue(QN, N_DEFAULT));
const VERSION = getQueryValue(QVERSION, 1);
let m_status;

const TRANSLATION = {};
let m_scrollTop  = null;
let m_scrollLeft = null;

let m_lastColor = RED_OBJECT;
let m_lastMove = null;
const last = getQueryValue(QLAST, null);
if (last != null) {
    let c = last.charAt(0);
    switch (c) {
        case RED_OBJECT.shortName:
            m_lastColor = RED_OBJECT;
            break;
        case BLUE_OBJECT.shortName:
            m_lastColor = BLUE_OBJECT;
            break;
        default:
    }
    m_lastMove = getTextPosition(last.substring(1));
    // in case the earlier board was larger
    if ((m_lastMove.x >= m_N) || (m_lastMove.y >= m_N)) {
        m_lastMove = null;
    }
    window.scrollTo(CANVAS.getBoundingClientRect().left, CANVAS.getBoundingClientRect().top);
}

let ms_share = document.getElementById("ShareButton");
if (navigator.share) {
    // https://css-tricks.com/how-to-use-the-web-share-api/      
    // iOS Safari, desktop Safari, Android Chrome, Android Firefox                  
    ms_share.addEventListener("click", event => {
        if (navigator.share) {
            navigator.share({
                title: document.title,
                text:  window.location.href,
                url:   window.location.href,
            });
        }
    });
} else {
    if (DEBUG) {
        ms_share.addEventListener("click", event => {
            console.log("Share button clicked, but not enabled.");
        });        
    } else {
        ms_share.remove();
        ms_share = null;
    }
}
/*
}*/

const SIZE = document.getElementById("Size");
const options = SIZE.children;
for (let i = 0; i < options.length; i++) {
    if (parseInt(options[i].value) == m_N) {
        SIZE.selectedIndex = i;
    }
}
SIZE.addEventListener('change', function(event) {
    const newN = parseInt(SIZE.options.item(SIZE.options.selectedIndex).value);

    if (newN != m_N) {
        // reset the current ctx origin
        translateBack();

        const oldN = m_N;
        const oldStatus = m_status;
        
        const newBinLength = nBinLength(newN);
        let newStatus = "0".repeat(newBinLength);
        
        // loop up to newN
        loopBoard(function(pos) {
            m_N = oldN;
            m_status = oldStatus;
            const colorObj = getStatus(pos);
            if (!colorObj.empty) {
                m_N = newN;
                // swap the status
                m_status = newStatus;
                setStatus(pos, colorObj);
                newStatus = m_status;
            }
        }, newN);
        m_N = newN;
        
        draw(newStatus);
    }
});

const V30 = Math.PI/6;
let m_s; // hex tile side length
let m_dx;
let m_dy;
let m_borderY;

let m_screenInterval = null;

draw();

window.addEventListener('popstate', function(event) {
    const state = event.state;
    
    if (state != null) {
        m_N = state.N;
        m_lastColor = COLOR_OBJECTS[state.lastColor];
        m_lastMove = ((state.lastMove == null) ? null : getTextPosition(state.lastMove));
        m_status = state.state;
    }
    
    // reset the current origin
    translateBack();
    draw();
    
    //let href = window.location.href;
    //href = href.substring(0, href.indexOf("?")); // does not include "?" if available
    //window.location.href = href + state.query;
});

CANVAS.addEventListener('mousedown', function(event) {
    const xy = getEventCoordinates(event);
    const move = getPosition(xy);
    if (move != null) { // only when mouse down on valid tile position
        m_scrollTop  = window.scrollTop;
        m_scrollLeft = window.scrollLeft;
    } else {
        m_scrollTop  = null;
        m_scrollLeft = null;
    }
    if (move != null) {
        if ((m_lastMove != null) && m_lastMove.equals(move)) {
            m_href = m_previousHref;
            m_lastMove = null;
        } else if (!getStatus(move).empty) {
            if (DEBUG) {
                if (document.getElementById("edit").checked) {
                    m_previousHref = m_href;
                    if (m_lastMove != null) {
                        setStatus(m_lastMove, m_lastColor);
                    }
                    m_lastColor = getStatus(move).next;
                    m_lastMove = move;
                }
            } else {
                return;
            }
        } else {
            m_previousHref = m_href;
            // first set previous move
            if (m_lastMove != null) {
                setStatus(m_lastMove, m_lastColor);
                // color of current move
                m_lastColor = m_lastColor.next;
            }
            m_lastMove = move;
        }
        newQuery();
        drawStatus();
    } else {
        loopButtons(xy, function(button) {
            CTX.strokeStyle = "black";
            CTX.lineWidth = 2;
            drawCircle(button, button.r);
            button.action();
        });
    }
});
CANVAS.addEventListener('mouseup', function(event) {
    // avoid accidental pan while clicking
    if ((m_scrollTop != null) && (m_scrollLeft != null)) {
        window.scrollTo(m_scrollLeft, m_scrollTop);
    }
});
// show tooltip
CANVAS.addEventListener('mousemove', function(event) {
    // https://stackoverflow.com/questions/17064913/display-tooltip-in-canvas-graph
    const xy = getEventCoordinates(event);
    const move = getPosition(xy);

    CANVAS.title = "";
    if (move == null) {
        loopButtons(xy, function(button) {
            CANVAS.title = button.tooltip;
        });
    }
}, false);

document.getElementById("Fullscreen").addEventListener('click', function() {
    openFullscreen();
});
document.addEventListener('fullscreenchange', function(event) {
    if (m_fullscreen) {
        closeFullscreen();
    } else {
        m_fullscreen = true;
    }
});
window.matchMedia("(orientation: portrait)").addEventListener("change", function(event) {
    // https://dev.to/smpnjn/how-to-detect-device-orientation-with-javascript-29e5
    if (m_fullscreen) {
        draw();
    }
});

if (DEBUG) {
    const checkBothColors = function() {
        const initLastMove = function() {
            do {
                const move = new Vector2D(Math.floor(Math.random()*m_N), Math.floor(Math.random()*m_N));
                if (getStatus(move) === m_lastColor) {
                    m_lastMove = move;
                }
            } while (m_lastMove == null);
        };
        m_lastMove = null;
        m_lastColor = BLUE_OBJECT;
        initLastMove();
        
        const blueSolution = getSolution(m_lastColor);
        if (blueSolution) {
            return blueSolution;
        } else {
            m_lastMove = null;
            m_lastColor = RED_OBJECT;
            initLastMove();

            const redSolution = getSolution(m_lastColor);
            if (redSolution) {
                return redSolution;
            }
        }
        return false;
    };
    document.getElementById("random").addEventListener('click', function() {
        const binLength = nBinLength(m_N);
        m_status = "0".repeat(binLength);

        let goal = 40; // N=19, 500-242000 loops
        if (m_N == 3) {
            goal = 3; // max 33 after 100000 loops
        }
        if (m_N == 6) {
            goal = 13; // max 14 after 100000 loops
        }
        if (m_N == 9) {
            goal = 22; // max 23 after 100000 loops
        }
        if (m_N == 11) {
            goal = 26; // max 27 after 100000 loops
        }
        if (m_N == 13) {
            goal = 32; // max 33 after 100000 loops
        }
        if (m_N == 14) {
            goal = 32; // max 33 after 100000 loops
        }
        if (m_N == 19) {
            goal = 51; // max 52 after 35000 loops
        }
        let i = 1000;
        let found = false;
        const sols = new Array(2*goal);
        do {
            randomBoard();
            const solution = checkBothColors();
            if (solution) {
                if (solution.length > goal) {
                    found = true;
                }
                if (sols[solution.length] == undefined) {
                    sols[solution.length] = 1;
                }
                sols[solution.length]++;
            }
            console.log("loop random");
            i--;
        } while ((!found) && (i > 0));
        console.log(sols);
        // 52 steps, after 35000 loops :: ?N=19&V=1&L=rB2&S=PQNMDQPGHDEGEQDQPDPNNEGGNQHMGDHEGMEDGNGEHMNMPNQDGPPPPQENQPDENMEEMNGGDGEHENQEPQMHNPGMGPDPNENMEGDQPPDMHGMHDEHEPEQQDHPNMNPQ2
        
        newQuery();
        drawBoard(false);
        drawStatus();
    });
    document.getElementById("recalc").addEventListener('click', function() {
        checkBothColors();
    });
} else {
    document.getElementById("Debug").remove();
}

function setScreenSize() {
    const w = window.screen.availWidth;
    const h =  window.screen.availHeight;
    const q = 3/2;//CANVAS.width/CANVAS.height; // 3/2
    if (w > h) { // landscape
        if (w/q < h) {
            CANVAS.width = w;
            CANVAS.height = w/q;
        } else {
            CANVAS.width = h*q;
            CANVAS.height = h;
        }
    } else if (w < h) { // portrait
        if (h*q < w) {
            CANVAS.width = h;
            CANVAS.height = h*q;
        } else {
            CANVAS.width = w;
            CANVAS.height = w/q;
        }
    }
    m_screenHeight = h;
    m_screenWidth = w;
    m_screenQuota = w/h;
}

function getStatus(pos) {
    if (isIllegalPosition(pos)) {
        return COLOR_OBJECTS[0];
    }
    const p = pos.x + m_N*pos.y;
    const n = Math.floor(p/NBIN);
    const bin = NBIN - 1 - (p - n*NBIN);

    return COLOR_OBJECTS[parseInt(getBin(getInt(m_status.charAt(n))).charAt(bin))];
}
function setStatus(pos, colorObj) {
    const p = pos.x + m_N*pos.y;
    
    const n = Math.floor(p/NBIN);
    const i = p - NBIN*n;
    
    const c = m_status.charAt(n);
    
    const colorInt = COLOR_OBJECTS.indexOf(colorObj);
    
    let remove = COLOR_OBJECTS.indexOf(getStatus(pos));
    
    const w = getChar(getInt(c) + (colorInt - remove)*Math.pow(BINBASE, i));
    m_status = m_status.substring(0, n) + w + m_status.substring(n + 1);
}

function getSolution(colorObj) {
    if (colorObj.empty) {
        return false;
    }
    // prio direction
    let dir = [ 0, 1, 2, 3, 4, 5 ];
    if (colorObj === BLUE_OBJECT) {
        dir = [ 3, 1, 5, 4, 0, 2 ];
    }
    
    const marked = [];
    const starts = [];
    
    loopBoard(function(pos) {
        if ((getStatus(pos) === colorObj) || ((m_lastColor === colorObj) && pos.equals(m_lastMove))) {
            marked.push(pos);
            pos.path = [];
            if (colorObj.isStartEdge(pos)) {
                starts.push(pos);
                pos.path.push(pos);
            }
        }
    });

    const getVectorObjectFromArray = function(arr, x, y) {
        return arr.find(obj => { return ((obj.x == x) && (obj.y == y)); });
    }
    
    let fronts = starts;
    let found = null;
    // Breadth first search
    for (let i = m_N*m_N; (i > 0) && (found == null); i--) { // i is not used as index
        let nexts = [];
        for (let j = 0; (j < fronts.length) && (found == null); j++) {
            const pos = fronts[j];
            
            for (let k = 0; (k < 6) && (found == null); k++) {
                const neighbour = getVectorObjectFromArray(marked, pos.x + steps[dir[k]].dx, pos.y + steps[dir[k]].dy);
                if (neighbour != undefined) {
                    const neighbourPath = neighbour.path;
                    if (neighbourPath.length == 0) {
                        pos.path.forEach(s => {
                            neighbourPath.push(s);
                        });
                        neighbourPath.push(neighbour);
                        nexts.push(neighbour);
                    }
                    if (colorObj.isEndEdge(neighbour)) {
                        found = neighbour;
                    }
                }
            }
        }
        fronts = nexts;
    }
    if (found != null) {
        return found.path;
    }
    return false;
}

// https://stackoverflow.com/questions/49223096/is-there-a-way-to-document-parameters-of-a-function-parameter
/**
 * A function to be passed as an argument.
 * @callback loopBoardCallback
 * @param {Vector2D} pos - The position.
 * @param {Vector2D} i   - The index.
 */
/**
 * Loops through all positions of the board and calls the callback function.
 * @param {loopBoardCallback} fcn - Callback for each cell in the board.
 * @param {integer} [n = m_N]     - Loop length, same for column and row.
 */
function loopBoard(fcn, n) {
    if (n == undefined) {
        n = m_N;
    }
    let i = 0;
    for (let r = 0; r < n; r++) { // y
        for (let c = 0; c < n; c++) { // x
            fcn(new Vector2D(c, r), i);
            i++;
        }
    }
}


/* SUPPORTING FUNCTIONS */

function getChar(i) {
    return BIN.charAt(i);
}
function getInt(c) {
    return BIN.indexOf(c);
}
function getBin(i) { // Most significant bit first
    let s = "";
    let n = NBIN;
    while (n > -1) {
        let q = (BINBASE - 1)*Math.pow(BINBASE, n);
        if (i >= q) {
            s = s + "2";
            i = i - q;
        } else {
            q = q/2;
            if (i >= q) {
                s = s + "1";
                i = i - q;
            } else {
                s = s + "0";
            }
        }
        n--;
    }
    s = BINZERO + s;
    s = s.substring(s.length - NBIN);
    return s;
}

function getPositionText(pos) {
    if (pos == null) {
        return null;
    }
    return String.fromCharCode(65 + pos.x) + (pos.y + 1);
}
function getTextPosition(txt) {
    return new Vector2D(txt.charCodeAt(0) - 65, parseInt(txt.substring(1)) - 1);
}
function isIllegalPosition(pos) {
    return ((pos == null) || 
            (pos.x < 0) || (pos.x >= m_N) ||
            (pos.y < 0) || (pos.y >= m_N));
}
function getPositionXY(pos) {
    const x = pos.x*2*m_dx - pos.y*m_dx;
    const y = pos.y*(m_dy + m_s);
    return new Vector2D(x, y);
}
function getPosition(xy) {
    const pos = new Vector2D();
    pos.x = Math.floor((xy.x + m_dx)/(2*m_dx));
    pos.y = Math.floor((xy.y + m_s)/(3*m_s/2));
    if (pos.y % 2 > 0.5) {
        pos.x = Math.floor((xy.x + m_dx)/(2*m_dx) + 0.5);
    }
    pos.x = Math.floor(pos.x + pos.y/2);
    
    const centerXY = getPositionXY(pos);
    if (xy.minus(centerXY).length() > m_s*0.9*Math.cos(V30)) {
        return null;
    }
    if (!isIllegalPosition(pos)) {
        return pos;
    }
    return null;
}

function randomBoard() {
    const board = new Array(m_N*m_N);

    const time = new Date().getTime();
    
    let n = 0;
    let i = 0;
    do {
        do {
            i = Math.floor(Math.random()*m_N*m_N);
        } while (board[i] != undefined);
        board[i] = RED_OBJECT;
        n++;
        do {
            i = Math.floor(Math.random()*m_N*m_N);
        } while (board[i] != undefined);
        board[i] = BLUE_OBJECT;
        n++;
    } while (n < (m_N*m_N)*0.95);
    
    let col = RED_OBJECT;
    for (let i = (m_N*m_N - 1); i > -1; i--) {
        if (board[i] == undefined) {
            board[i] = col;
            col = col.next;
        }
    }
    loopBoard(function(pos, i) {
        setStatus(pos, board[i]);
    });
}


/* GRAPHICS */

function draw(state) {
    setScreenSize();
    document.getElementById("New").href = FILE_NAME + QN + "=" + m_N;
    if (state == undefined) {
        state = decodeURI(getQueryValue(QSTATUS, ""));
        if (DEBUG) {
            console.log(state);
            //console.log(encodeURI(state));
        }
    }
    const binLength = nBinLength(m_N);
    const statusDefault = "0".repeat(binLength);
    m_status = (state + statusDefault).substring(0, binLength);

    //initLengths();
    m_s = Math.min(CANVAS.height, CANVAS.width)/(2*m_N + 1.2);
    m_dx = m_s*Math.cos(V30);
    m_dy = m_s*Math.sin(V30);

    m_borderY = m_s*1.2; // border from mid of top left side

    if (m_screenInterval != null) {
        clearInterval(m_screenInterval);
    }
    m_screenInterval = setInterval(function() {
        if (Math.floor(100*window.screen.availWidth/window.screen.availHeight) != Math.floor(100*m_screenQuota)) {
            //console.log(window.screen.availWidth/window.screen.availHeight);
            //console.log(TRANSLATION);
            translateBack();
            draw();
        }
    }, 1000);

    CTX.fillStyle = BACKGROUND_COLOR;
    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
    
    const n = (m_N - 1)/2;
    TRANSLATION.x = CANVAS.width/2 - m_dx*n;
    TRANSLATION.y = CANVAS.height/2 - m_s*n - m_dy*n;
    translate(TRANSLATION);
    
    drawBoard(false);
    drawStatus();
}

function drawStatus(ctx) {
    if ((ms_share == null) || DEBUG) {
        updateShareLinks();
    }
    if (ctx == undefined) {
        ctx = CTX;
    }
    function drawColoredHex(pos, colorObj) {
        if (colorObj == undefined) {
            colorObj = getStatus(pos);
        }
        if (isIllegalPosition(pos)) {
            return;
        }
        ctx.fillStyle = colorObj.color;
        ctx.lineWidth = colorObj.lineWidth*m_s/HEX_LINE_QUOTE;
        
        setShadow("#444444", colorObj.shadowBlur*ctx.lineWidth/4);
        
        drawHexPosition(pos, ctx);
        
        clearShadow();
    }
    
    ctx.strokeStyle = "black";
    loopBoard(function(pos) {
        drawColoredHex(pos);
    });
    
    const showNextMoveSide = function(lastColorObj) {
        if (lastColorObj == undefined) {
            lastColorObj = m_lastColor;
        }
        const n = (m_N - 1)/2;
        translate(m_dx*n, m_s*n + m_dy*n);
        
        ctx.lineWidth = 10;
        ctx.lineCap = "round";

        const h = m_s*n + m_dy*n + (m_s - m_dy/2) + m_borderY + ctx.lineWidth/2 + 3;
        const dw = m_borderY;

        if (lastColorObj === BLUE_OBJECT) {
            ctx.strokeStyle = RED_COLOR;
        } else {
            ctx.strokeStyle = BACKGROUND_COLOR;
        }

        drawLine(-h*Math.tan(V30)   + dw, -h, h*Math.tan(2*V30) - dw, -h, ctx);
        drawLine(-h*Math.tan(2*V30) + dw,  h, h*Math.tan(V30)   - dw,  h, ctx);

        if (lastColorObj === RED_OBJECT) {
            ctx.strokeStyle = BLUE_COLOR;
        } else {
            ctx.strokeStyle = BACKGROUND_COLOR;
        }

        rotate(-2*V30);
        drawLine(-h*Math.tan(2*V30) + dw, -h, h*Math.tan(V30)   - dw, -h, ctx);
        drawLine(-h*Math.tan(V30)   + dw,  h, h*Math.tan(2*V30) - dw,  h, ctx);
        rotateBack();

        translateBack();
        resetStyle(ctx);
    };
    
    let solved = false;
    if (m_lastMove != null) {
        const showMove = function(noWait) {
            ctx.strokeStyle = "gold";
            drawColoredHex(m_lastMove, m_lastColor);
            solved = drawSolution(m_lastColor, ctx);
            if (noWait) {
                showNextMoveSide();
            } else {
                setTimeout(showNextMoveSide, 100);
            }
        };
        if (m_firstDraw) {
            showNextMoveSide(m_lastColor.next);
            ctx.fillStyle = "gold";
            drawHexPosition(m_lastMove, ctx);
            setTimeout(function() {
                showMove(false);
            }, 500);
            m_firstDraw = false;
        } else {
            showMove(true);
        }
    }
    
    return solved;
}
function drawBoard(drawTiles, ctx) {
    if (ctx == undefined) {
        ctx = CTX;
    }

    function drawBorder() {
        ctx.beginPath();
    
        ctx.moveTo(0, 0);
        const y = -(m_s - m_dy/2) - m_borderY;
        ctx.lineTo(Math.tan(V30)*y, y);
    
        translate((m_N - 1)*2*m_dx, 0);
        ctx.lineTo(-Math.tan(2*V30)*y, y);
        ctx.lineTo(0, 0);
        translateBack();
    
        ctx.closePath();    
        ctx.fill();
    }
    
    ctx.fillStyle = RED_COLOR;
    
    // top
    drawBorder();
    
    const opposite = getPositionXY(new Vector2D(-(m_N - 1), -(m_N - 1)));
    
    // bottom
    scale(-1, -1);
    translate(opposite);            
    drawBorder();            
    translateBack(); 
    scaleBack();

    ctx.fillStyle = BLUE_COLOR;
    
    // left
    rotate(-2*V30);
    scale(-1, 1);
    drawBorder();
    
    // right
    scale(-1, -1);
    translate(opposite);           
    drawBorder();            
    translateBack(); 
    scaleBack();
    
    scaleBack();
    rotateBack();

    if (drawTiles) {
        ctx.strokeStyle = "black";
        ctx.fillStyle = BOARD_COLOR;
        loopBoard(function(pos) {
            drawHexPosition(pos);
        });
    }

    ctx.fillStyle = BOARD_TEXT_COLOR;
    ctx.font = Math.floor(m_s) + "px Arial";
        
    const n = m_N - 1;
    for (let i = 0; i < m_N; i++) {
        const row = i + 1;
        const col = String.fromCharCode(65 + i);
        
        let q = 1.5;
        let qx = q*m_dx;
        const qy = q*m_dy;
        
        translate(i*2*m_dx, 0); // center of hexagon in first row
        drawTextCentered( qy, -qx, col); // note swapping qx and qy
        translate(-n*m_dx, n*(m_s + m_dy)); // center of hexagon in last row
        drawTextCentered(-qy,  qx, col); // note swapping qx and qy
        translateBack();
        translateBack();
        
        q = 1.7;
        qx = q*m_dx;
        
        translate(-i*m_dx, i*(m_s + m_dy)); // center of hexagon in first column
        drawTextCentered(-qx, 0, row);
        translate(n*2*m_dx, 0); // center of hexagon in last column
        drawTextCentered( qx, 0, row);
        translateBack();
        translateBack();
    }
    
    // clear all old buttons, TODO remove from ctx
    BUTTONS.splice(0);

    const buttonR = (m_N < 9 ? m_N*m_s/10 : m_s);
    const buttonX = 2.2*buttonR;
    const buttonY = (m_N < 10 ? m_s : m_s*4);
    
    drawButton(buttonX, buttonY, buttonR, "<", "Back", function() {
        window.history.back();
    }, ctx);
    
    drawButton(2*buttonX, buttonY, buttonR, ">", "Forward", function() {
        window.history.forward();
    }, ctx);
    
    setTimeout(function() {
        drawButton(3*buttonX, buttonY + 2.2*buttonR, buttonR, "F", "Fullscreen toggle", function() {
            if (m_fullscreen) {
                closeFullscreen();
            } else {
                openFullscreen();
            }
        }, ctx);
    }, 500);

    if (ms_share != null) {
        drawButton(3.5*buttonX, buttonY, buttonR, "S", "Share", function() {
            // https://stackoverflow.com/questions/809057/how-do-i-programmatically-click-on-an-element-in-javascript
            ms_share.dispatchEvent(new MouseEvent("click", {
                "view": window,
                "bubbles": true,
                "cancelable": false
            }));
        }, ctx);
    }
}
function drawSolution(colorObj, ctx) {
    if (ctx == undefined) {
        ctx = CTX;
    }
    const solution = getSolution(colorObj);
    if (solution) {
        if (DEBUG) {
            console.log("Solved by " + colorObj.name + ", path length: " + solution.length);
        }
        // assume solution is ordered
        ctx.strokeStyle = colorObj.markColor;
        ctx.lineWidth = m_s/5;
        ctx.lineCap = "round";
        
        let pos = solution[0];
        let xy = getPositionXY(pos);
        let da;
        if (colorObj.isStartEdge(pos) && colorObj.next.isOwnEdge(pos)) {
            if (colorObj === RED_OBJECT) { // red
                da = new Vector2D(m_dx/2, -(m_s - m_dy/2));
            } else {
                da = new Vector2D(-m_dx, 0);
            }
        } else {
            da = xy.minus(getPositionXY(solution[1])).mult(0.5);
        }
        drawRelativeLine(xy, da, ctx);
        solution.forEach((pos, i) => {
            if (i != 0) {
                const a = getPositionXY(pos);
                drawLine(xy, a, ctx);
                xy = a;
            }
        });
        pos = solution[solution.length - 1];
        if (colorObj.isEndEdge(pos) && colorObj.next.isOwnEdge(pos)) {
            if (colorObj === RED_OBJECT) { // red
                da = new Vector2D(-m_dx/2, (m_s - m_dy/2));
            } else {
                da = new Vector2D(m_dx, 0);
            }
        } else {
            da = xy.minus(getPositionXY(solution[solution.length - 2])).mult(0.5);
        }
        drawRelativeLine(xy, da, ctx);
        return true;
    }
    return false;
}

function drawHexPosition(pos, ctx) {
    if (ctx == undefined) {
        ctx = CTX;
    }
    const drawHex = function(a, ctx) { // center at a
        if (ctx == undefined) {
            ctx = CTX;
        }
        let s = m_s;
        let dx = m_dx;
        let dy = m_dy;
    
        const w = ctx.lineWidth;

        if (w > COLOR_OBJECTS[0].lineWidth*m_s/HEX_LINE_QUOTE) {
            const q = (m_s - w*0.6)/m_s;
            s = m_s*q;
            dx = m_dx*q;
            dy = m_dy*q;
        }
    
        ctx.beginPath();
    
        translate(a.x, a.y - s, ctx);
        ctx.moveTo(0, 0); // starting at top
        ctx.lineTo(dx, dy);
        ctx.lineTo(dx, dy + s);
        ctx.lineTo(0, 2*dy + s);
        ctx.lineTo(-dx, dy + s);
        ctx.lineTo(-dx, dy);
        translateBack();
    
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
    
    drawHex(getPositionXY(pos), ctx);
}

// note x, y in default canvas coordinates
function drawButton(x, y, r, txt, tooltip, actionFcn, ctx) {
    if (ctx == undefined) {
        ctx = CTX;
    }
    const translation = translateBack();
    const buttonVector = new Vector2D(x - translation.x, y - translation.y);
    buttonVector.r = r;
    buttonVector.tooltip = tooltip;
    buttonVector.action = actionFcn;
    
    let shift = 0;
    loopButtons(buttonVector, function(button) {
        if (DEBUG) {
            console.log("Warning: buttons overlap for " + tooltip);
        }
        shift = 2*r/3;
        buttonVector.add(new Vector2D(shift, shift));
    })
    BUTTONS.push(buttonVector);
    
    
    ctx.fillStyle = "gold";
    fillCircle(x + shift, y + shift, r, ctx);
    
    ctx.font = "bold " + r + "px Arial";
    drawTextCentered(x + shift, y + shift, txt, "black", CTX_TRANSPARENT_COLOR, ctx);
    
    translate(translation);
}
function loopButtons(xy, fcn) {
    BUTTONS.forEach(button => {
        if (xy.minus(button).length() < button.r) {
            fcn(button);
        }
    });
}
function getEventCoordinates(event) {
    let rect = event.target.getBoundingClientRect();
    const x = event.clientX - rect.left - TRANSLATION.x;
    const y = event.clientY - rect.top - TRANSLATION.y;
    return new Vector2D(x, y);
}


/* QUERY */

//{
// separate blue and red
// bin 2: ?N=19&L=bS18&R=00000000000000000000000000000000000000000000000000000000000G1&B=00000000000000000000000000000000000000000000000000000000000W

// binbase 2: ?N=19&V=1&L=bB2&
//    S=4000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000062
// binbase 3: ?N=19&L=bS17&
//    S=fViA000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090000002
// becomes encoded:
// binbase 4: ?N=19&V=1&L=bP18&
//    S=G000söQ00aeG00dee00ÅÅQ0R83000420000200000000a4000ä2000000000000000000000000000000000s8000d1
//      40000000082000000000000000000s000003600903100000000000010006060000000000012006030Reee7%C3%A4%C3%85%C3%85%C3%851
//      i%5Doh%7C%7Br%7Bfnr%5Dh~~q.~%C3%A5%5D%C3%A5%5Do%C3%B6roqinq~%7B%5Di~eo%C3%85%C3%85r%7B%7Bei%C3%B6%C3%85ffef%7Bqrri%C3%A5%7Boqeq%C3%85erfofehh%5D~fe%C3%A5ih%C3%B6h.err.f%C3%A5%C3%85i%C3%B6%7C2
/*
}*/
function newQuery() {
    if (m_lastMove == null) {
        // replace prohibits using Back
        // the user can still reload shared link
        window.location.replace(m_href);
        return;
    }
    const state = {
        N: m_N,
        lastColor: COLOR_OBJECTS.indexOf(m_lastColor),
        lastMove: ((m_lastMove == null) ? null : getPositionText(m_lastMove)),
        state: m_status,
    };
    let query = QN + "=" + m_N;
    query = query + QVERSION + "=" + 1;
    
    let titleInfo = new Date().toLocaleString('sv', { timeZoneName: 'short' }).substring(0, 16).replaceAll(" ", "T");
    if (m_lastMove != null) {
        query = query + QLAST + "=" + m_lastColor.shortName + getPositionText(m_lastMove);
        titleInfo = m_lastColor.name + " " + getPositionText(m_lastMove) + " " + titleInfo;
    }
    
    const theState = function(state) {
        let query = "";
        let last = false;
        for (let i = Math.min(state.length - 1, m_N*m_N/NBIN); i > -1 ; i--) { // use N, as it may have been changed
            if (state.charAt(i) != "0") {
                last = true;
            }
            if (last) {
                query = state.charAt(i) + query;
            }
        }
        if (!last) {
            query = "0";
        }
        return query;
    }
    query = query + QSTATUS + "=" + encodeURI(theState(m_status));
        
    let href = window.location.href;
    href = href.substring(0, href.indexOf("?")); // does not include "?" if available
    
    m_href = href + query;
    
    const title = document.getElementsByTagName("TITLE")[0];
    const earlierTitle = title.innerText;
    title.innerText = title.innerText + " " + titleInfo; 
    
    setTimeout(function() {
        history.pushState(state, "", m_href);
        title.innerText = earlierTitle;
    }, 10);
}

function updateShareLinks() {
    // https://schier.co/blog/pure-html-share-buttons
    // https://developers.facebook.com/tools/debug/
    // https://www.linkedin.com/post-inspector/

    let title = encodeURI(document.title);
    let url = encodeURIComponent(window.location.href);
    
    if (LOCALEXECUTION) {
        url = encodeURIComponent(SHAREBASELINK) + window.location.search;
    }

    let links = [];
    links.push({id:"Mail",     url:"mailto:?subject=" + title + "&body=" + url});
    links.push({id:"Twitter",  url:"https://twitter.com/share?url=" + url + "&text=" + title}); // &text=<TEXT>via=<USERNAME>
    links.push({id:"LinkedIn", url:"https://www.linkedin.com/shareArticle?url=" + url + "&title=" + title + "&summary=" + title});
    links.push({id:"Facebook", url:"https://www.facebook.com/sharer/sharer.php?u=" + url});

    let share = document.getElementById("ShareLinks");
    
    links.forEach(link => {
        let a = document.getElementById(link.id);
        if (a == null) {
            a = document.createElement("A");
            a.className = "share";
            a.setAttribute("class", "share");
            a.id = link.id;
            a.innerHTML = a.id;
            share.appendChild(a);
        }
        a.href = link.url;
    });
}


/* OTHERS */

function logVariable(obj) { // use as logVariables({theVariableNameToBeLogged})
    // can just as well just log the object directly... but this is cooler
    // https://stackoverflow.com/questions/4602141/variable-name-as-a-string-in-javascript
    let s = "";
    Object.keys(obj).forEach((key, i) => {
        s = s + key + ": " + Object.values(obj)[i];
        if (i < (Object.keys(obj).length - 1)) {
            s = s + ", ";
        }
    });
    console.log(s);
}


/* FULLSCREEN */

// https://www.w3schools.com/jsref/met_element_exitfullscreen.asp
function openFullscreen() {
    const e = document.getElementById("FullscreenDiv");
    if (e.requestFullscreen) {
        e.requestFullscreen();
    } else if (e.webkitRequestFullscreen) { // Safari
        e.webkitRequestFullscreen();
    } else if (elem.msRequestFullscreen) { // IE11
        e.msRequestFullscreen();
    }
    setTimeout(draw, 500);
}
function closeFullscreen() {
    if (document.fullscreenElement) {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { // Safari
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { // IE11
            document.msExitFullscreen();
        }
    }
    setTimeout(function() {
        draw();
        m_fullscreen = false;
    }, 500);
} 
//]]>
</script>
    </body>
</html>
